export interface TransactionProps {
  id?: string; // UUID from database, optional for new transactions
  user_id: string; // UUID reference to auth.users
  account_id: string; // UUID reference to accounts table
  category_id?: string; // UUID reference to categories table, optional
  amount: number;
  description?: string; // Optional in database schema
  date: Date | string; // Accepts string for parsing in constructor, but stores as Date
  is_expense: boolean;
  created_at?: Date | string; // Database timestamp, optional for new transactions
}

export class Transaction {
  id?: string;
  user_id: string;
  account_id: string;
  category_id?: string;
  amount: number;
  description?: string;
  date: Date;
  is_expense: boolean;
  created_at?: Date;

  constructor({ id, user_id, account_id, category_id, amount, description, date, is_expense, created_at }: TransactionProps) {
    // Validation
    if (!user_id) throw new Error('user_id is required');
    if (!account_id) throw new Error('account_id is required');
    if (amount === undefined || amount === null) throw new Error('amount is required');
    if (typeof amount !== 'number' || isNaN(amount)) throw new Error('amount must be a valid number');
    if (is_expense === undefined || is_expense === null) throw new Error('is_expense is required');
    if (!date) throw new Error('date is required');

    this.id = id || undefined; // Will be generated by database
    this.user_id = user_id;
    this.account_id = account_id;
    this.category_id = category_id || undefined;
    this.amount = amount;
    this.description = description || undefined;
    this.date = date instanceof Date ? date : new Date(date); // Always store Date type
    this.is_expense = is_expense;
    this.created_at = created_at ? (created_at instanceof Date ? created_at : new Date(created_at)) : undefined;
  }

  toJSON(): { [key: string]: any } {
    return {
      id: this.id,
      user_id: this.user_id,
      account_id: this.account_id,
      category_id: this.category_id,
      amount: this.amount,
      description: this.description,
      date: this.date.toISOString(), // Serialize as ISO string
      is_expense: this.is_expense,
      created_at: this.created_at?.toISOString(),
    };
  }

  isOverBudget(budgetLimit: number): boolean {
    if (typeof budgetLimit !== 'number' || budgetLimit < 0) {
      throw new Error('budgetLimit must be a non-negative number');
    }
    return this.is_expense && this.amount > budgetLimit;
  }

  isRecurring(): boolean {
    if (!this.description) return false;
    const keywords = ['subscription', 'membership', 'monthly', 'weekly', 'annual', 'recurring'];
    return keywords.some(keyword =>
      this.description.toLowerCase().includes(keyword)
    );
  }

  // Validation method for database operations
  static validate(props: TransactionProps): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!props.user_id) errors.push('user_id is required');
    if (!props.account_id) errors.push('account_id is required');
    if (props.amount === undefined || props.amount === null) errors.push('amount is required');
    if (typeof props.amount !== 'number' || isNaN(props.amount)) errors.push('amount must be a valid number');
    if (props.is_expense === undefined || props.is_expense === null) errors.push('is_expense is required');
    if (!props.date) errors.push('date is required');

    // Validate date format
    if (props.date) {
      const dateObj = props.date instanceof Date ? props.date : new Date(props.date);
      if (isNaN(dateObj.getTime())) {
        errors.push('date must be a valid date');
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}
