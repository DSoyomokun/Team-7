export interface GoalProps {
  id?: string; // UUID from database, optional for new goals
  user_id: string; // UUID reference to auth.users
  name: string;
  target_amount: number;
  current_amount?: number; // Current progress towards goal, defaults to 0
  target_date?: Date | string; // Optional target date
  is_completed?: boolean; // Whether goal has been completed, defaults to false
  created_at?: Date | string; // Database timestamp, optional for new goals
}

export class Goal {
  id?: string;
  user_id: string;
  name: string;
  target_amount: number;
  current_amount: number;
  target_date?: Date;
  is_completed: boolean;
  created_at?: Date;

  constructor({ id, user_id, name, target_amount, current_amount = 0, target_date, is_completed = false, created_at }: GoalProps) {
    // Validation
    if (!user_id) throw new Error('user_id is required');
    if (!name || name.trim().length === 0) throw new Error('name is required and cannot be empty');
    if (target_amount === undefined || target_amount === null) throw new Error('target_amount is required');
    if (typeof target_amount !== 'number' || isNaN(target_amount)) throw new Error('target_amount must be a valid number');
    if (target_amount <= 0) throw new Error('target_amount must be greater than 0');
    if (current_amount !== undefined && (typeof current_amount !== 'number' || isNaN(current_amount))) {
      throw new Error('current_amount must be a valid number');
    }
    if (current_amount < 0) throw new Error('current_amount cannot be negative');

    this.id = id || undefined; // Will be generated by database
    this.user_id = user_id;
    this.name = name.trim();
    this.target_amount = target_amount;
    this.current_amount = current_amount;
    this.target_date = target_date ? (target_date instanceof Date ? target_date : new Date(target_date)) : undefined;
    this.is_completed = is_completed;
    this.created_at = created_at ? (created_at instanceof Date ? created_at : new Date(created_at)) : undefined;
  }

  toJSON(): { [key: string]: any } {
    return {
      id: this.id,
      user_id: this.user_id,
      name: this.name,
      target_amount: this.target_amount,
      current_amount: this.current_amount,
      target_date: this.target_date?.toISOString(),
      is_completed: this.is_completed,
      created_at: this.created_at?.toISOString(),
    };
  }

  // Progress tracking methods
  getProgressPercentage(): number {
    if (this.target_amount === 0) return 0;
    const percentage = (this.current_amount / this.target_amount) * 100;
    return Math.min(percentage, 100); // Cap at 100%
  }

  getRemainingAmount(): number {
    return Math.max(this.target_amount - this.current_amount, 0);
  }

  addProgress(amount: number): number {
    if (typeof amount !== 'number' || isNaN(amount)) {
      throw new Error('amount must be a valid number');
    }
    if (amount < 0) {
      throw new Error('amount must be positive');
    }

    this.current_amount += amount;
    
    // Auto-complete if target is reached
    if (this.current_amount >= this.target_amount && !this.is_completed) {
      this.is_completed = true;
    }

    return this.current_amount;
  }

  subtractProgress(amount: number): number {
    if (typeof amount !== 'number' || isNaN(amount)) {
      throw new Error('amount must be a valid number');
    }
    if (amount < 0) {
      throw new Error('amount must be positive');
    }

    this.current_amount = Math.max(this.current_amount - amount, 0);
    
    // Un-complete if we're now below target
    if (this.current_amount < this.target_amount && this.is_completed) {
      this.is_completed = false;
    }

    return this.current_amount;
  }

  setProgress(amount: number): number {
    if (typeof amount !== 'number' || isNaN(amount)) {
      throw new Error('amount must be a valid number');
    }
    if (amount < 0) {
      throw new Error('amount cannot be negative');
    }

    this.current_amount = amount;
    
    // Update completion status
    this.is_completed = this.current_amount >= this.target_amount;

    return this.current_amount;
  }

  isOverdue(): boolean {
    if (!this.target_date || this.is_completed) return false;
    return new Date() > this.target_date;
  }

  getDaysRemaining(): number | null {
    if (!this.target_date || this.is_completed) return null;
    
    const today = new Date();
    const diffTime = this.target_date.getTime() - today.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    return diffDays;
  }

  getFormattedProgress(currency: string = 'USD'): string {
    try {
      const formatter = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: currency,
      });
      return `${formatter.format(this.current_amount)} / ${formatter.format(this.target_amount)}`;
    } catch (error) {
      // Fallback if currency is invalid
      return `$${this.current_amount.toFixed(2)} / $${this.target_amount.toFixed(2)}`;
    }
  }

  markComplete(): void {
    this.is_completed = true;
  }

  markIncomplete(): void {
    this.is_completed = false;
  }

  // Static validation method
  static validate(props: GoalProps): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!props.user_id) errors.push('user_id is required');
    if (!props.name || props.name.trim().length === 0) errors.push('name is required and cannot be empty');
    if (props.target_amount === undefined || props.target_amount === null) errors.push('target_amount is required');
    if (typeof props.target_amount !== 'number' || isNaN(props.target_amount)) errors.push('target_amount must be a valid number');
    if (props.target_amount <= 0) errors.push('target_amount must be greater than 0');
    
    if (props.current_amount !== undefined) {
      if (typeof props.current_amount !== 'number' || isNaN(props.current_amount)) {
        errors.push('current_amount must be a valid number');
      }
      if (props.current_amount < 0) {
        errors.push('current_amount cannot be negative');
      }
    }

    // Validate target_date format if provided
    if (props.target_date) {
      const dateObj = props.target_date instanceof Date ? props.target_date : new Date(props.target_date);
      if (isNaN(dateObj.getTime())) {
        errors.push('target_date must be a valid date');
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  // Static method to create common goal templates
  static createGoalTemplates(): { name: string; target_amount: number; description: string }[] {
    return [
      { name: 'Emergency Fund', target_amount: 1000, description: 'Build your emergency fund' },
      { name: 'Vacation Fund', target_amount: 2000, description: 'Save for your next vacation' },
      { name: 'New Car Down Payment', target_amount: 5000, description: 'Save for a car down payment' },
      { name: 'Pay Off Credit Card', target_amount: 3000, description: 'Eliminate credit card debt' },
      { name: 'Home Down Payment', target_amount: 20000, description: 'Save for a home down payment' },
      { name: 'Retirement Contribution', target_amount: 6000, description: 'Annual retirement savings goal' },
    ];
  }

  // Static method to calculate daily savings needed
  static calculateDailySavingsNeeded(targetAmount: number, targetDate: Date): number {
    const today = new Date();
    const diffTime = targetDate.getTime() - today.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays <= 0) return targetAmount; // Need to save all at once if overdue
    
    return targetAmount / diffDays;
  }
}