export interface AccountProps {
  id?: string; // UUID from database, optional for new accounts
  user_id: string; // UUID reference to auth.users
  name: string;
  type: string; // e.g., 'checking', 'savings', 'credit', 'cash'
  balance?: number; // Current balance, defaults to 0
  plaid_item_id?: string; // Optional Plaid integration ID
  created_at?: Date | string; // Database timestamp, optional for new accounts
}

export class Account {
  id?: string;
  user_id: string;
  name: string;
  type: string;
  balance: number;
  plaid_item_id?: string;
  created_at?: Date;

  constructor({ id, user_id, name, type, balance = 0, plaid_item_id, created_at }: AccountProps) {
    // Validation
    if (!user_id) throw new Error('user_id is required');
    if (!name || name.trim().length === 0) throw new Error('name is required and cannot be empty');
    if (!type || type.trim().length === 0) throw new Error('type is required and cannot be empty');
    if (balance !== undefined && (typeof balance !== 'number' || isNaN(balance))) {
      throw new Error('balance must be a valid number');
    }

    this.id = id || undefined; // Will be generated by database
    this.user_id = user_id;
    this.name = name.trim();
    this.type = type.toLowerCase().trim();
    this.balance = balance;
    this.plaid_item_id = plaid_item_id || undefined;
    this.created_at = created_at ? (created_at instanceof Date ? created_at : new Date(created_at)) : undefined;
  }

  toJSON(): { [key: string]: any } {
    return {
      id: this.id,
      user_id: this.user_id,
      name: this.name,
      type: this.type,
      balance: this.balance,
      plaid_item_id: this.plaid_item_id,
      created_at: this.created_at?.toISOString(),
    };
  }

  // Balance calculation methods
  updateBalance(amount: number, isExpense: boolean): number {
    if (typeof amount !== 'number' || isNaN(amount)) {
      throw new Error('amount must be a valid number');
    }
    if (amount < 0) {
      throw new Error('amount must be positive');
    }

    if (isExpense) {
      this.balance -= amount;
    } else {
      this.balance += amount;
    }

    return this.balance;
  }

  addTransaction(amount: number): number {
    return this.updateBalance(amount, false);
  }

  subtractTransaction(amount: number): number {
    return this.updateBalance(amount, true);
  }

  getFormattedBalance(currency: string = 'USD'): string {
    try {
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: currency,
      }).format(this.balance);
    } catch (error) {
      // Fallback if currency is invalid
      return `$${this.balance.toFixed(2)}`;
    }
  }

  isOverdrawn(): boolean {
    return this.balance < 0;
  }

  canAfford(amount: number): boolean {
    if (typeof amount !== 'number' || isNaN(amount)) {
      throw new Error('amount must be a valid number');
    }
    return this.balance >= amount;
  }

  // Static validation method
  static validate(props: AccountProps): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!props.user_id) errors.push('user_id is required');
    if (!props.name || props.name.trim().length === 0) errors.push('name is required and cannot be empty');
    if (!props.type || props.type.trim().length === 0) errors.push('type is required and cannot be empty');
    
    if (props.balance !== undefined) {
      if (typeof props.balance !== 'number' || isNaN(props.balance)) {
        errors.push('balance must be a valid number');
      }
    }

    // Validate account type
    const validTypes = ['checking', 'savings', 'credit', 'cash', 'investment'];
    if (props.type && !validTypes.includes(props.type.toLowerCase().trim())) {
      errors.push(`type must be one of: ${validTypes.join(', ')}`);
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  // Static method to get valid account types
  static getValidTypes(): string[] {
    return ['checking', 'savings', 'credit', 'cash', 'investment'];
  }
}