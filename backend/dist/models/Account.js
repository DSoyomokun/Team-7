"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
class Account {
    constructor({ id, user_id, name, type, balance = 0, plaid_item_id, created_at }) {
        // Validation
        if (!user_id)
            throw new Error('user_id is required');
        if (!name || name.trim().length === 0)
            throw new Error('name is required and cannot be empty');
        if (!type || type.trim().length === 0)
            throw new Error('type is required and cannot be empty');
        if (balance !== undefined && (typeof balance !== 'number' || isNaN(balance))) {
            throw new Error('balance must be a valid number');
        }
        this.id = id || undefined; // Will be generated by database
        this.user_id = user_id;
        this.name = name.trim();
        this.type = type.toLowerCase().trim();
        this.balance = balance;
        this.plaid_item_id = plaid_item_id || undefined;
        this.created_at = created_at ? (created_at instanceof Date ? created_at : new Date(created_at)) : undefined;
    }
    toJSON() {
        return {
            id: this.id,
            user_id: this.user_id,
            name: this.name,
            type: this.type,
            balance: this.balance,
            plaid_item_id: this.plaid_item_id,
            created_at: this.created_at?.toISOString(),
        };
    }
    // Balance calculation methods
    updateBalance(amount, isExpense) {
        if (typeof amount !== 'number' || isNaN(amount)) {
            throw new Error('amount must be a valid number');
        }
        if (amount < 0) {
            throw new Error('amount must be positive');
        }
        if (isExpense) {
            this.balance -= amount;
        }
        else {
            this.balance += amount;
        }
        return this.balance;
    }
    addTransaction(amount) {
        return this.updateBalance(amount, false);
    }
    subtractTransaction(amount) {
        return this.updateBalance(amount, true);
    }
    getFormattedBalance(currency = 'USD') {
        try {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: currency,
            }).format(this.balance);
        }
        catch (error) {
            // Fallback if currency is invalid
            return `$${this.balance.toFixed(2)}`;
        }
    }
    isOverdrawn() {
        return this.balance < 0;
    }
    canAfford(amount) {
        if (typeof amount !== 'number' || isNaN(amount)) {
            throw new Error('amount must be a valid number');
        }
        return this.balance >= amount;
    }
    // Static validation method
    static validate(props) {
        const errors = [];
        if (!props.user_id)
            errors.push('user_id is required');
        if (!props.name || props.name.trim().length === 0)
            errors.push('name is required and cannot be empty');
        if (!props.type || props.type.trim().length === 0)
            errors.push('type is required and cannot be empty');
        if (props.balance !== undefined) {
            if (typeof props.balance !== 'number' || isNaN(props.balance)) {
                errors.push('balance must be a valid number');
            }
        }
        // Validate account type
        const validTypes = ['checking', 'savings', 'credit', 'cash', 'investment'];
        if (props.type && !validTypes.includes(props.type.toLowerCase().trim())) {
            errors.push(`type must be one of: ${validTypes.join(', ')}`);
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    // Static method to get valid account types
    static getValidTypes() {
        return ['checking', 'savings', 'credit', 'cash', 'investment'];
    }
}
exports.Account = Account;
//# sourceMappingURL=Account.js.map