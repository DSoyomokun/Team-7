"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Goal = void 0;
class Goal {
    constructor({ id, user_id, name, type, target_amount, current_amount = 0, target_date, completed = false, created_at, updated_at }) {
        // Validation
        if (!user_id)
            throw new Error('user_id is required');
        if (!name || name.trim().length === 0)
            throw new Error('name is required and cannot be empty');
        if (!type || !['savings', 'debt'].includes(type))
            throw new Error('type must be either "savings" or "debt"');
        if (target_amount === undefined || target_amount === null)
            throw new Error('target_amount is required');
        if (typeof target_amount !== 'number' || isNaN(target_amount))
            throw new Error('target_amount must be a valid number');
        if (target_amount <= 0)
            throw new Error('target_amount must be greater than 0');
        if (current_amount !== undefined && (typeof current_amount !== 'number' || isNaN(current_amount))) {
            throw new Error('current_amount must be a valid number');
        }
        if (current_amount < 0)
            throw new Error('current_amount cannot be negative');
        if (!target_date)
            throw new Error('target_date is required');
        this.id = id || undefined; // Will be generated by database
        this.user_id = user_id;
        this.name = name.trim();
        this.type = type;
        this.target_amount = target_amount;
        this.current_amount = current_amount;
        this.target_date = target_date instanceof Date ? target_date : new Date(target_date);
        this.completed = completed;
        this.created_at = created_at ? (created_at instanceof Date ? created_at : new Date(created_at)) : undefined;
        this.updated_at = updated_at ? (updated_at instanceof Date ? updated_at : new Date(updated_at)) : undefined;
    }
    toJSON() {
        return {
            id: this.id,
            user_id: this.user_id,
            name: this.name,
            type: this.type,
            target_amount: this.target_amount,
            current_amount: this.current_amount,
            target_date: this.target_date.toISOString(),
            completed: this.completed,
            created_at: this.created_at?.toISOString(),
            updated_at: this.updated_at?.toISOString(),
        };
    }
    // Progress tracking methods
    getProgressPercentage() {
        if (this.target_amount === 0)
            return 0;
        const percentage = (this.current_amount / this.target_amount) * 100;
        return Math.min(percentage, 100); // Cap at 100%
    }
    getRemainingAmount() {
        return Math.max(this.target_amount - this.current_amount, 0);
    }
    addProgress(amount) {
        if (typeof amount !== 'number' || isNaN(amount)) {
            throw new Error('amount must be a valid number');
        }
        if (amount < 0) {
            throw new Error('amount must be positive');
        }
        this.current_amount += amount;
        // Auto-complete if target is reached
        if (this.current_amount >= this.target_amount && !this.completed) {
            this.completed = true;
        }
        return this.current_amount;
    }
    subtractProgress(amount) {
        if (typeof amount !== 'number' || isNaN(amount)) {
            throw new Error('amount must be a valid number');
        }
        if (amount < 0) {
            throw new Error('amount must be positive');
        }
        this.current_amount = Math.max(this.current_amount - amount, 0);
        // Un-complete if we're now below target
        if (this.current_amount < this.target_amount && this.completed) {
            this.completed = false;
        }
        return this.current_amount;
    }
    setProgress(amount) {
        if (typeof amount !== 'number' || isNaN(amount)) {
            throw new Error('amount must be a valid number');
        }
        if (amount < 0) {
            throw new Error('amount cannot be negative');
        }
        this.current_amount = amount;
        // Update completion status
        this.completed = this.current_amount >= this.target_amount;
        return this.current_amount;
    }
    isOverdue() {
        if (!this.target_date || this.completed)
            return false;
        return new Date() > this.target_date;
    }
    getDaysRemaining() {
        if (!this.target_date || this.completed)
            return null;
        const today = new Date();
        const diffTime = this.target_date.getTime() - today.getTime();
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays;
    }
    getFormattedProgress(currency = 'USD') {
        try {
            const formatter = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: currency,
            });
            return `${formatter.format(this.current_amount)} / ${formatter.format(this.target_amount)}`;
        }
        catch (error) {
            // Fallback if currency is invalid
            return `$${this.current_amount.toFixed(2)} / $${this.target_amount.toFixed(2)}`;
        }
    }
    markComplete() {
        this.completed = true;
    }
    markIncomplete() {
        this.completed = false;
    }
    // Static validation method
    static validate(props) {
        const errors = [];
        if (!props.user_id)
            errors.push('user_id is required');
        if (!props.name || props.name.trim().length === 0)
            errors.push('name is required and cannot be empty');
        if (!props.type || !['savings', 'debt'].includes(props.type))
            errors.push('type must be either "savings" or "debt"');
        if (props.target_amount === undefined || props.target_amount === null)
            errors.push('target_amount is required');
        if (typeof props.target_amount !== 'number' || isNaN(props.target_amount))
            errors.push('target_amount must be a valid number');
        if (props.target_amount <= 0)
            errors.push('target_amount must be greater than 0');
        if (props.current_amount !== undefined) {
            if (typeof props.current_amount !== 'number' || isNaN(props.current_amount)) {
                errors.push('current_amount must be a valid number');
            }
            if (props.current_amount < 0) {
                errors.push('current_amount cannot be negative');
            }
        }
        // Validate target_date format - it's required
        if (!props.target_date) {
            errors.push('target_date is required');
        }
        else {
            const dateObj = props.target_date instanceof Date ? props.target_date : new Date(props.target_date);
            if (isNaN(dateObj.getTime())) {
                errors.push('target_date must be a valid date');
            }
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
    // Static method to create common goal templates
    static createGoalTemplates() {
        return [
            { name: 'Emergency Fund', target_amount: 1000, description: 'Build your emergency fund' },
            { name: 'Vacation Fund', target_amount: 2000, description: 'Save for your next vacation' },
            { name: 'New Car Down Payment', target_amount: 5000, description: 'Save for a car down payment' },
            { name: 'Pay Off Credit Card', target_amount: 3000, description: 'Eliminate credit card debt' },
            { name: 'Home Down Payment', target_amount: 20000, description: 'Save for a home down payment' },
            { name: 'Retirement Contribution', target_amount: 6000, description: 'Annual retirement savings goal' },
        ];
    }
    // Static method to calculate daily savings needed
    static calculateDailySavingsNeeded(targetAmount, targetDate) {
        const today = new Date();
        const diffTime = targetDate.getTime() - today.getTime();
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        if (diffDays <= 0)
            return targetAmount; // Need to save all at once if overdue
        return targetAmount / diffDays;
    }
}
exports.Goal = Goal;
//# sourceMappingURL=Goal.js.map